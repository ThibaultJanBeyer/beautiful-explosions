{
  "version": 3,
  "sources": ["../node_modules/uuid/dist/esm-browser/rng.js", "../node_modules/uuid/dist/esm-browser/stringify.js", "../node_modules/uuid/dist/esm-browser/native.js", "../node_modules/uuid/dist/esm-browser/v4.js", "../src/helpers/dom-element.ts", "../src/helpers/random.ts", "../src/BubbleExplosion.ts"],
  "sourcesContent": ["// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;", "export const updateStyle = (\n  el: HTMLElement,\n  style: Partial<ElementCSSInlineStyle['style']>\n): void => {\n  for (const key in style) {\n    if (Object.prototype.hasOwnProperty.call(style, key)) {\n      const value = style[key]\n      el.style[key] = value as string\n    }\n  }\n}\n\nexport const createElement = ({\n  tag = '',\n  classList = '',\n  value = '',\n  appendElement,\n  style,\n}: {\n  tag?: string\n  classList?: string\n  value?: string\n  appendElement?: HTMLElement | ShadowRoot | null\n  style?: Partial<ElementCSSInlineStyle['style']>\n}): HTMLElement => {\n  const el = document.createElement(tag)\n  el.className = classList\n  el.innerHTML = value\n  if (style) updateStyle(el, style)\n  if (appendElement != null) appendElement.append(el)\n  return el\n}\n", "export const randomInt = (min: number, max: number): number =>\n  Math.floor(Math.random() * (max - min + 1)) + min\n", "import { v4 as uuidv4 } from 'uuid'\nimport { updateStyle, createElement } from './helpers/dom-element'\nimport { randomInt } from './helpers/random'\n\nexport const BubbleExplosion = ({\n  element,\n  eventListener = 'click',\n  content,\n  particles,\n  areaSize,\n  shouldAppear,\n}: {\n  element: HTMLElement\n  eventListener?: string\n  content?: CSSStyleDeclaration['content']\n  particles: { size?: number; direction?: 'up' | 'down'; amount?: number }\n  areaSize?: { x?: number; y?: number }\n  shouldAppear?: boolean\n}): { trigger: () => void } => {\n  const duration = 800\n  const elementLifeSpan = duration / 4\n\n  class BE extends HTMLElement {\n    colors = ['#D81CB8', '#05A542', '#DE215F', '#1CD8CE', '#1B3F3D']\n\n    container: HTMLElement\n\n    constructor() {\n      super()\n      this.attachShadow({ mode: 'open' })\n\n      createElement({\n        tag: 'style',\n        appendElement: this.shadowRoot,\n        value: /*CSS*/ `\n        .circle { border-radius: 50% }\n\n        .bubble {\n          position: absolute;\n          border: 2px solid red;\n          transform: scale(0, 0);\n          z-index: 1;\n        }\n\n        ${\n          content\n            ? /*CSS*/ `\n              .bubble { border: 0 }\n              .bubble::before { content: '${content}' }\n            `\n            : ''\n        }\n      `,\n      })\n\n      if (shouldAppear)\n        updateStyle(element, {\n          transform: `${element.style.transform || ''} scale(1, 0)`,\n          opacity: '0',\n          transformOrigin:\n            particles?.direction === 'up'\n              ? 'bottom'\n              : particles?.direction === 'down'\n              ? 'top'\n              : 'middle',\n          transition: `\n          ${element.style.transition ? `${element.style.transition},` : ''}\n          opacity ${elementLifeSpan}ms ease-in-out ${duration / 6}ms, \n          transform ${elementLifeSpan}ms ease-in-out ${duration / 6}ms,\n          font-size ${elementLifeSpan}ms ease-in-out ${duration / 6}ms`,\n        })\n      else\n        updateStyle(element, {\n          transition: `\n          ${element.style.transition ? `${element.style.transition},` : ''}\n          opacity ${elementLifeSpan}ms ease-in-out, \n          transform ${elementLifeSpan}ms ease-in-out,\n          font-size ${elementLifeSpan}ms ease-in-out`,\n          transformOrigin:\n            particles?.direction === 'up'\n              ? 'top'\n              : particles?.direction === 'down'\n              ? 'bottom'\n              : 'middle',\n        })\n\n      this.container = createElement({\n        tag: 'div',\n        appendElement: this.shadowRoot,\n      })\n\n      if (eventListener) element.addEventListener(eventListener, this.trigger)\n    }\n\n    randomTranslateInt = (xy: 'x' | 'y', size: number, rect: DOMRect) =>\n      randomInt(\n        size / 2,\n        (areaSize && areaSize[xy]) || Math.max(rect.width, 50)\n      )\n\n    trigger = async () => {\n      const rect = element.getBoundingClientRect()\n      const amount = particles?.amount || 25\n\n      createElement({\n        tag: 'style',\n        appendElement: this.shadowRoot,\n        value: this.getBubbleCss(amount, rect),\n      })\n\n      if (shouldAppear)\n        updateStyle(element, {\n          transform: element.style.transform.replace(\n            'scale(1, 0)',\n            'scale(1, 1)'\n          ),\n          opacity: '1',\n        })\n      else\n        updateStyle(element, {\n          transform: `${element.style.transform} scale(0, 0)`,\n          pointerEvents: 'none',\n        })\n\n      if (eventListener)\n        element.removeEventListener(eventListener, this.trigger)\n\n      await Promise.all(\n        new Array(amount).fill(null).map(() => this.spawnBubble(rect))\n      )\n    }\n\n    getBubbleCss = (amount: number, rect: DOMRect): string => {\n      const size =\n        particles?.size || Math.max(Math.min(rect.height, rect.width), 25)\n\n      console.log(size)\n\n      let css = ''\n      for (let index = 0; index < amount; index++) {\n        const temp = randomInt(1, size)\n        let tempR = randomInt(0, 360)\n        let translateY = this.randomTranslateInt('y', size, rect)\n        let translateX = this.randomTranslateInt('x', size, rect)\n        let startTranslateY = 0\n        let startTranslateX = 0\n\n        if (particles?.direction === 'up' || particles?.direction === 'down') {\n          tempR = 0\n          translateX -= this.randomTranslateInt('x', size, rect)\n          startTranslateX = translateX\n          if (particles?.direction === 'up') translateY *= -1\n        }\n\n        css += /*CSS*/ `\n          .bubble:nth-child(${index}) {\n            width: ${temp}px;\n            height: ${temp}px;\n            font-size: ${temp}px;\n            animation-duration: ${duration - randomInt(0, 750)}ms;\n            animation-name: bMove--${index};\n            animation-delay: 100ms;\n          }\n\n          @keyframes bMove--${index} {\n            0% { transform: rotate(${tempR}deg) translate3d(${startTranslateX}px, ${startTranslateY}px, 0) scale(0, 0); opacity: 1; }\n            50% { opacity: 0.7; }\n            100% {\n              transform:\n                rotate(${tempR}deg)\n                translate3d(\n                  ${translateX}px,\n                  ${translateY}px,\n                  1px\n                )\n                scale(1, 1);\n              opacity: 0;\n            }\n          }\n        `\n      }\n      return css\n    }\n\n    spawnBubble = (rect: DOMRect) =>\n      new Promise((resolve) => {\n        const el = createElement({\n          tag: 'span',\n          classList: 'bubble',\n          style: {\n            top: rect.top + rect.height / 2 + 'px',\n            left: rect.left + rect.width / 2 + 'px',\n            borderColor: this.colors[randomInt(0, this.colors.length - 1)],\n          },\n        })\n        if (randomInt(0, 1) === 0) el.classList.add('circle')\n        this.container.appendChild(el)\n\n        setTimeout(() => {\n          this.container.removeChild(el)\n          resolve('ok')\n        }, duration)\n      })\n  }\n\n  const componentName = `ba-bubble-explosion-${uuidv4()}`\n  customElements.define(componentName, BE)\n  const shadowElement = createElement({ tag: componentName }) as BE\n  document.body.append(shadowElement)\n\n  return {\n    trigger: shadowElement.trigger,\n  }\n}\n"],
  "mappings": "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",
  "names": ["getRandomValues", "rnds8", "rng", "byteToHex", "i", "unsafeStringify", "arr", "offset", "randomUUID", "native_default", "v4", "options", "buf", "offset", "native_default", "rnds", "rng", "i", "unsafeStringify", "v4_default", "updateStyle", "el", "style", "key", "value", "createElement", "tag", "classList", "appendElement", "randomInt", "min", "max", "BubbleExplosion", "element", "eventListener", "content", "particles", "areaSize", "shouldAppear", "BE", "createElement", "updateStyle", "xy", "size", "rect", "randomInt", "amount", "css", "index", "temp", "tempR", "translateY", "translateX", "startTranslateY", "startTranslateX", "resolve", "el", "componentName", "v4_default", "shadowElement"]
}
